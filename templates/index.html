{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <h1 class="text-center text-shadow mb-4 fw-bold">Image Gallery</h1>

    <!-- Sorting Options -->
    <div class="row mb-3">
        <div class="col-12">
            <!-- Sort Options -->
            <div class="d-flex justify-content-end">
                <div class="dropdown me-2">
                    <button class="btn btn-outline-primary dropdown-toggle" type="button" id="sortDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi bi-sort-down"></i> Sort: {{ sort_by.title() }} ({{ 'A-Z' if sort_order == 'asc' else 'Z-A' if sort_by == 'name' else 'New-Old' if sort_order == 'desc' else 'Old-New' }})
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="sortDropdown">
                        <li><h6 class="dropdown-header">By Name</h6></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'name' and sort_order == 'asc' }}" href="{{ url_for('index', sort_by='name', sort_order='asc') }}">
                            <i class="bi bi-sort-alpha-down"></i> Name (A-Z)
                        </a></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'name' and sort_order == 'desc' }}" href="{{ url_for('index', sort_by='name', sort_order='desc') }}">
                            <i class="bi bi-sort-alpha-up"></i> Name (Z-A)
                        </a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><h6 class="dropdown-header">By Date</h6></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'date' and sort_order == 'desc' }}" href="{{ url_for('index', sort_by='date', sort_order='desc') }}">
                            <i class="bi bi-calendar-plus"></i> Newest First
                        </a></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'date' and sort_order == 'asc' }}" href="{{ url_for('index', sort_by='date', sort_order='asc') }}">
                            <i class="bi bi-calendar-minus"></i> Oldest First
                        </a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><h6 class="dropdown-header">By Size</h6></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'size' and sort_order == 'desc' }}" href="{{ url_for('index', sort_by='size', sort_order='desc') }}">
                            <i class="bi bi-arrow-up"></i> Largest First
                        </a></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'size' and sort_order == 'asc' }}" href="{{ url_for('index', sort_by='size', sort_order='asc') }}">
                            <i class="bi bi-arrow-down"></i> Smallest First
                        </a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><h6 class="dropdown-header">By Dimensions</h6></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'dimensions' and sort_order == 'desc' }}" href="{{ url_for('index', sort_by='dimensions', sort_order='desc') }}">
                            <i class="bi bi-arrows-fullscreen"></i> Highest Resolution
                        </a></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'dimensions' and sort_order == 'asc' }}" href="{{ url_for('index', sort_by='dimensions', sort_order='asc') }}">
                            <i class="bi bi-arrows-angle-contract"></i> Lowest Resolution
                        </a></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'aspect' and sort_order == 'desc' }}" href="{{ url_for('index', sort_by='aspect', sort_order='desc') }}">
                            <i class="bi bi-aspect-ratio"></i> Widest First
                        </a></li>
                        <li><a class="dropdown-item{{ ' active' if sort_by == 'aspect' and sort_order == 'asc' }}" href="{{ url_for('index', sort_by='aspect', sort_order='asc') }}">
                            <i class="bi bi-phone"></i> Tallest First
                        </a></li>
                    </ul>
                </div>
                <div class="dropdown">
                    <button class="btn btn-outline-secondary dropdown-toggle" type="button" id="viewDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi bi-grid-3x3-gap"></i> View
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="viewDropdown">
                        <li><a class="dropdown-item" href="#" onclick="setGridSize(2)">
                            <i class="bi bi-grid"></i> Large (2 columns)
                        </a></li>
                        <li><a class="dropdown-item active" href="#" onclick="setGridSize(4)">
                            <i class="bi bi-grid-3x3-gap"></i> Medium (4 columns)
                        </a></li>
                        <li><a class="dropdown-item" href="#" onclick="setGridSize(6)">
                            <i class="bi bi-grid-3x3-gap-fill"></i> Small (6 columns)
                        </a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Info -->
    <div class="row mb-2">
        <div class="col">
            <small class="text-muted">
                <span id="photoCount">{{ images|length }}</span> photo(s)
            </small>
        </div>
    </div>

    <!-- Upload Form -->
    <form id="uploadForm" action="{{ url_for('upload_file') }}" method="POST" enctype="multipart/form-data" class="mb-4">
        <div class="input-group">
            <input type="file" name="files" multiple class="form-control" id="fileInput" accept="image/*">
            <button type="submit" class="btn btn-primary" id="uploadBtn">Upload</button>
        </div>
        <div id="uploadAlert" class="mt-2 d-none alert alert-danger" role="alert">
            Please select at least one file to upload.
        </div>
        <div id="batchInfo" class="mt-2 d-none alert alert-info" role="alert">
            <strong>Large batch detected!</strong> Files will be automatically processed in batches to ensure reliable upload.
        </div>
        <div id="uploadProgress" class="mt-2 d-none">
            <div class="progress mb-2" style="height: 25px;">
                <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                     role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                    0%
                </div>
            </div>
            <div class="row text-center">
                <div class="col-3">
                    <small class="text-muted">Uploaded</small>
                    <div id="uploadedCount" class="fw-bold text-success">0</div>
                </div>
                <div class="col-3">
                    <small class="text-muted">Skipped</small>
                    <div id="skippedCount" class="fw-bold text-warning">0</div>
                </div>
                <div class="col-3">
                    <small class="text-muted">Errors</small>
                    <div id="errorCount" class="fw-bold text-danger">0</div>
                </div>
                <div class="col-3">
                    <small class="text-muted">Remaining</small>
                    <div id="remainingCount" class="fw-bold text-primary">0</div>
                </div>
            </div>
            <div class="text-center mt-2">
                <small id="currentStatus" class="text-muted">Preparing upload...</small>
            </div>
        </div>
    </form>

    <!-- Image Grid -->
    <div class="row row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-lg-4 photo-grid">
        {% for image in images %}
        <div class="col mb-4 photo-card-container">
            <div class="card shadow-sm photo-card">
                <div class="card-img-container">
                    <img src="{{ url_for('uploaded_file', filename=image['name']) }}" class="card-img-top" alt="{{ image['name'] }}" loading="lazy">
                </div>
                <div class="card-body text-center">
                    <h5 class="card-title text-truncate" title="{{ image['name'] }}">{{ image['name'] }}</h5>
                    <p class="card-text text-muted small">
                        <i class="bi bi-calendar3"></i> {{ image['mod_time'].strftime('%m/%d/%Y') }}<br>
                        <i class="bi bi-file-earmark"></i> {{ image['size_mb'] }}MB
                        {% if image['width'] and image['height'] %}
                        <br><i class="bi bi-aspect-ratio"></i> {{ image['width'] }}Ã—{{ image['height'] }}
                        {% endif %}
                    </p>
                    <form action="{{ url_for('delete_file', filename=image['name']) }}" method="POST" onsubmit="return confirm('Are you sure you want to delete this photo?')"
                        <button type="submit" class="btn btn-danger btn-sm w-100">
                            <i class="bi bi-trash"></i> Delete
                        </button>
                    </form>
                </div>
            </div>
        </div>
        {% endfor %}
    </div>

    <!-- No Images Message -->
    {% if not images %}
    <p class="text-center text-muted">No images uploaded yet. Start by uploading your files!</p>
    {% endif %}
</div>

<script>
let uploadInProgress = false;
let currentBatch = 0;
let totalBatches = 0;
let uploadStats = {
    uploaded: 0,
    skipped: 0,
    errors: 0,
    total: 0
};
let configBatchSize = 50; // Default, will be loaded from server

// Load configuration from server
async function loadConfig() {
    try {
        const response = await fetch('/config');
        const config = await response.json();
        configBatchSize = config.batch_size || 50;
    } catch (error) {
        console.warn('Could not load config, using defaults:', error);
    }
}

// File input change handler
document.getElementById("fileInput").addEventListener("change", function () {
    const fileInput = this;
    const batchInfo = document.getElementById("batchInfo");
    const uploadBtn = document.getElementById("uploadBtn");
    
    if (fileInput.files.length > configBatchSize) {
        batchInfo.classList.remove("d-none");
        uploadBtn.textContent = "Upload Batch";
    } else {
        batchInfo.classList.add("d-none");
        uploadBtn.textContent = "Upload";
    }
});

// Upload form submission handler
document.getElementById("uploadForm").addEventListener("submit", function (event) {
    event.preventDefault(); // Always prevent default form submission
    
    const fileInput = document.getElementById("fileInput");
    const alertBox = document.getElementById("uploadAlert");
    
    if (!fileInput.files.length) {
        alertBox.classList.remove("d-none");
        return;
    }
    
    alertBox.classList.add("d-none");
    
    const files = Array.from(fileInput.files);
    
    if (files.length > configBatchSize) {
        // Use client-side batching for large uploads
        startBatchUpload(files);
    } else {
        // Use normal form submission for small uploads
        uploadSingleBatch(files);
    }
});

async function startBatchUpload(files) {
    uploadInProgress = true;
    const batchSize = Math.min(25, Math.floor(configBatchSize / 2)); // Smaller batches to avoid HTTP limits
    totalBatches = Math.ceil(files.length / batchSize);
    currentBatch = 0;
    
    // Reset stats
    uploadStats = {
        uploaded: 0,
        skipped: 0,
        errors: 0,
        total: files.length
    };
    
    // Show progress UI
    showProgressUI();
    updateProgress();
    
    // Process files in batches
    for (let i = 0; i < files.length; i += batchSize) {
        if (!uploadInProgress) break; // Allow cancellation
        
        currentBatch++;
        const batch = files.slice(i, i + batchSize);
        
        updateStatus(`Processing batch ${currentBatch} of ${totalBatches}...`);
        
        try {
            const result = await uploadBatch(batch);
            uploadStats.uploaded += result.uploaded || 0;
            uploadStats.skipped += result.skipped || 0;
            uploadStats.errors += result.errors || 0;
        } catch (error) {
            console.error('Batch upload error:', error);
            uploadStats.errors += batch.length;
        }
        
        updateProgress();
        
        // Small delay between batches to prevent overwhelming the server
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Upload complete
    uploadInProgress = false;
    
    // Show final results
    showUploadResults();
    
    // Auto-refresh if files were actually uploaded
    if (uploadStats.uploaded > 0) {
        // Countdown before automatic refresh
        let countdown = 2;
        const countdownInterval = setInterval(() => {
            updateStatus(`Upload complete! Refreshing in ${countdown} seconds...`);
            countdown--;
            if (countdown < 0) {
                clearInterval(countdownInterval);
                window.location.reload();
            }
        }, 1000);
    } else {
        // No files uploaded, just show completion message
        updateStatus('Upload complete! No files were uploaded.');
        // Reset form after a delay
        setTimeout(() => {
            hideProgressUI();
            document.getElementById("fileInput").value = '';
            document.getElementById("batchInfo").classList.add("d-none");
            document.getElementById("uploadBtn").textContent = "Upload";
            document.getElementById("uploadBtn").disabled = false;
        }, 3000);
    }
}

async function uploadBatch(files) {
    const formData = new FormData();
    
    files.forEach(file => {
        formData.append('files', file);
    });
    
    const response = await fetch('/upload', {
        method: 'POST',
        body: formData
    });
    
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    // Parse response to extract upload results
    const text = await response.text();
    
    // Simple parsing of flash messages to get counts
    const uploadedMatch = text.match(/Successfully uploaded (\d+) file/);
    const skippedMatch = text.match(/Skipped (\d+) file/);
    const errorMatch = text.match(/Failed to upload (\d+) file/);
    
    return {
        uploaded: uploadedMatch ? parseInt(uploadedMatch[1]) : files.length,
        skipped: skippedMatch ? parseInt(skippedMatch[1]) : 0,
        errors: errorMatch ? parseInt(errorMatch[1]) : 0
    };
}

async function uploadSingleBatch(files) {
    const uploadBtn = document.getElementById("uploadBtn");
    const originalText = uploadBtn.textContent;
    
    uploadBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Uploading...';
    uploadBtn.disabled = true;
    
    try {
        const formData = new FormData();
        files.forEach(file => {
            formData.append('files', file);
        });
        
        const response = await fetch('/upload', {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            // Show brief success message then refresh
            uploadBtn.innerHTML = '<span class="text-success">âœ“ Upload Complete!</span>';
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        } else {
            throw new Error(`Upload failed: ${response.status}`);
        }
    } catch (error) {
        console.error('Upload error:', error);
        alert('Upload failed. Please try again.');
    } finally {
        uploadBtn.textContent = originalText;
        uploadBtn.disabled = false;
    }
}

function showProgressUI() {
    document.getElementById("uploadProgress").classList.remove("d-none");
    document.getElementById("uploadBtn").innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Uploading...';
    document.getElementById("uploadBtn").disabled = true;
}

function hideProgressUI() {
    document.getElementById("uploadProgress").classList.add("d-none");
    document.getElementById("uploadBtn").disabled = false;
}

function updateProgress() {
    const processed = uploadStats.uploaded + uploadStats.skipped + uploadStats.errors;
    const percentage = uploadStats.total > 0 ? (processed / uploadStats.total) * 100 : 0;
    
    document.getElementById("progressBar").style.width = percentage + '%';
    document.getElementById("progressBar").textContent = Math.round(percentage) + '%';
    
    document.getElementById("uploadedCount").textContent = uploadStats.uploaded;
    document.getElementById("skippedCount").textContent = uploadStats.skipped;
    document.getElementById("errorCount").textContent = uploadStats.errors;
    document.getElementById("remainingCount").textContent = uploadStats.total - processed;
}

function updateStatus(message) {
    document.getElementById("currentStatus").textContent = message;
}

function showUploadResults() {
    let message = `Upload completed! `;
    if (uploadStats.uploaded > 0) {
        message += `${uploadStats.uploaded} uploaded`;
    }
    if (uploadStats.skipped > 0) {
        message += `, ${uploadStats.skipped} skipped`;
    }
    if (uploadStats.errors > 0) {
        message += `, ${uploadStats.errors} errors`;
    }
    
    updateStatus(message);
    
    // Change progress bar color based on results
    const progressBar = document.getElementById("progressBar");
    if (uploadStats.errors === 0) {
        progressBar.className = 'progress-bar bg-success';
    } else if (uploadStats.uploaded > 0) {
        progressBar.className = 'progress-bar bg-warning';
    } else {
        progressBar.className = 'progress-bar bg-danger';
    }
}

function setGridSize(columns) {
    const container = document.querySelector('.photo-grid');
    const colClass = `row-cols-lg-${columns}`;
    
    // Remove existing column classes
    container.className = container.className.replace(/row-cols-lg-\d+/g, '');
    
    // Add new column class
    container.classList.add(colClass);
    
    // Update active state in dropdown
    document.querySelectorAll('#viewDropdown + .dropdown-menu .dropdown-item').forEach(item => {
        item.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // Store preference in localStorage
    localStorage.setItem('gridSize', columns);
}

// Load saved grid size preference
function loadGridPreference() {
    const savedSize = localStorage.getItem('gridSize');
    if (savedSize) {
        setGridSize(parseInt(savedSize));
    }
}

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    loadConfig();
    loadGridPreference();
});
</script>
{% endblock %}